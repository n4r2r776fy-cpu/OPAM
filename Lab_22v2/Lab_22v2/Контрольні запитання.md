
---

## Контрольні запитання (відповіді)

1. **Коли та з якою метою доцільно використовувати двійкові файли?**
   Двійкові файли використовують, коли потрібно:

   * зберігати **структуровані дані** (числа, записи, об’єкти) без перетворення в текст;
   * мінімізувати **розмір файла** (немає зайвих символів форматування);
   * забезпечити **швидке читання/запис** (робота без парсингу рядків);
   * зберігати дані, які не призначені для ручного читання користувачем (службова/внутрішня інформація програми).

2. **У чому переваги та недоліки послідовних відносно типізованих двійкових файлів?**

   * **Переваги послідовних двійкових файлів:**

     * простий формат (дані йдуть один за одним);
     * менший розмір;
     * швидкий послідовний перегляд.
   * **Недоліки:**

     * важко виконувати **випадковий доступ** (до конкретного запису складно “перестрибнути”, якщо записи змінної довжини);
     * складніше змінювати/видаляти окремі записи — частіше треба переписувати файл.
   * **Типізовані (структуровані) двійкові файли** зручніші, коли всі записи однакового формату/довжини — тоді легше знайти запис за номером.

3. **Для чого в класах обробки потоків використовується властивість `BaseStream`?**
   `BaseStream` — це властивість у `BinaryReader` / `BinaryWriter` (та деяких інших класах), яка повертає **базовий потік**, з яким працює читач/записувач (наприклад, `FileStream`).
   Вона потрібна, щоб:

   * отримати доступ до **позиції** в потоці (`Position`);
   * подивитися **довжину** файла (`Length`);
   * при потребі виконати додаткові операції з потоком (переміщення, перевірка кінця файла тощо).

4. **Як створити двійковий файл?**
   У C# зазвичай використовують `FileStream` разом із `BinaryWriter`. Наприклад:

   ```csharp
   using (FileStream fs = new FileStream("data.dat", FileMode.Create, FileAccess.Write))
   using (BinaryWriter bw = new BinaryWriter(fs))
   {
       // запис даних
       bw.Write(123);        // int
       bw.Write(3.14);       // double
       bw.Write("Hello");    // string
   }
   ```

   Після закриття `using` файл буде створений/перезаписаний як двійковий.

5. **Як здійснюється зчитування/запис даних з двійкового файла?**

   * **Запис:** через `BinaryWriter`:

     ```csharp
     bw.Write(intValue);
     bw.Write(doubleValue);
     bw.Write(stringValue);
     ```
   * **Читання:** через `BinaryReader` у тому ж порядку, в якому записували:

     ```csharp
     int intValue = br.ReadInt32();
     double doubleValue = br.ReadDouble();
     string stringValue = br.ReadString();
     ```

   Дуже важливо дотримуватися **однакового порядку та типів** при читанні й записі.

6. **Як в двійкових файлах зберігаються рядки? Від чого залежить їх розмір?**
   У випадку `BinaryWriter`/`BinaryReader` рядок зберігається:

   * спочатку записується **довжина рядка** (у байтах або символах — залежно від реалізації),
   * потім — самі символи у вибраній **кодуванні** (найчастіше UTF-8 або UTF-16).
     Розмір рядка залежить від:
   * кількості символів;
   * типу кодування (скільки байтів на символ).

7. **Як здійснюється перевірка кінця двійкового файла і коли вона застосовується?**
   Часто використовують перевірку позиції потоку:

   ```csharp
   while (br.BaseStream.Position < br.BaseStream.Length)
   {
       // ще є дані для читання
       ...
   }
   ```

   Або іноді ловлять виняток (`EndOfStreamException`) при спробі прочитати більше, ніж є.
   Перевірка кінця файла потрібна при **послідовному читанні невідомої кількості записів**, коли наперед не відомо, скільки елементів у файлі.

8. **Як закрити файл? Що відбувається на рівні операційної системи при закритті файла?**
   У C# файл закривають або явно:

   ```csharp
   fs.Close();
   ```

   або автоматично через `using`, коли об’єкт потоку виходить за межі блоку:

   ```csharp
   using (FileStream fs = new FileStream(...))
   {
       ...
   } // тут fs автоматично закриється
   ```

   На рівні ОС при закритті:

   * буфери запису **скидаються на диск** (flush);
   * **звільняється файловий дескриптор** (handle);
   * знімаються можливі **блокування** файла для інших процесів.
