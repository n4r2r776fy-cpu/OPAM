
---

## Контрольні запитання (відповіді)

1. **Коли та з якою метою доцільно використовувати файли з структурованими даними в програмуванні?**
   Файли з структурованими даними використовують, коли:

   * є **чітка структура запису** (наприклад: прізвище, ім’я, бал, група тощо);
   * потрібно **зберігати записи однакового формату**;
   * важливо мати можливість **довільного доступу** до окремих записів (за номером, індексом);
   * потрібно **оновлювати/читати окремі записи**, не перечитуючи весь файл.
     Такі файли зручні для зберігання списків: студентів, книг, машин, товарів і т.д.

---

2. **У чому переваги та недоліки файла з структурованими даними стосовно файлів послідовного доступу?**

   **Переваги структурованого двійкового файла довільного доступу:**

   * можна **швидко перейти** до будь-якого запису за його номером (індексом);
   * легко **оновити один запис** без переписування всього файла;
   * структура запису фіксована — легше аналізувати й обробляти.

   **Недоліки:**

   * зазвичай потрібно **фіксована довжина полів** (наприклад, прізвище — 20 символів), що може давати **надлишок** даних (порожні символи);
   * складніше початкове **проєктування структури** (треба продумати формат кожного поля);
   * важче змінювати формат запису в майбутньому (якщо додати/змінити поле — старий файл може стати несумісним).

   **Файли послідовного доступу** простіші, але:

   * щоб знайти 1 запис, часто потрібно **переглянути всі попередні**;
   * важко змінювати конкретний запис без переписування файла.

---

3. **Що відбувається на рівні операційної системи при відкритті файла?**

   При відкритті файла ОС:

   * знаходить файл за **шляхом** (каталог + ім’я);
   * перевіряє **права доступу** (читання, запис);
   * створює **дескриптор (handle)** – внутрішній ідентифікатор відкритого файла;
   * встановлює **позицію в файлі** (зазвичай на початок);
   * може встановити **режим блокування** (іншим процесам заборонено/дозволено доступ).
     Програма працює не «напряму з файлом», а через цей файловий дескриптор.

---

4. **Для чого визначається структура запису?**

   Структура запису потрібна для того, щоб:

   * **однозначно описати формат** одного елемента (запису) у файлі: які поля, у якому порядку, яких типів;
   * знати **розмір одного запису в байтах**;
   * вміти порахувати, **де в файлі починається потрібний запис**;
   * правильно інтерпретувати прочитані байти як конкретні дані (наприклад, перші 20 байт – прізвище, наступні 2 – вік і т.д.).

   В коді це зазвичай структура/клас з полями (наприклад `struct Student { ... }`).

---

5. **Як підрахувати кількість байтів поля-рядка у структурованому файлі?**

   Залежить від того, **як саме зберігається рядок**:

   * Якщо рядок має **фіксовану довжину** (наприклад, 20 символів):

     * при кодуванні **ASCII**:
       `кількість_байт = кількість_символів` (20 символів = 20 байт);
     * при **Unicode / UTF-16** (C# `char` = 2 байти):
       `кількість_байт = кількість_символів * 2` (20 символів = 40 байт).
   * Якщо рядок зберігається як **масив байтів у певній кодуванні**, можна використати кодування:
     `Encoding.UTF8.GetByteCount(рядок)` — поверне, скільки байтів реально займає рядок.

   У контексті *структурованого файла довільного доступу* найчастіше використовують **фіксовану довжину полів** (наприклад, прізвище – рівно 20 символів), тоді розрахунок простий:
   `розмір_поля = максимальна_кількість_символів * байт_на_символ`.

---

6. **Як визначити зміщення у структурованому файлі для зчитування значення вказаного поля визначеного запису?**

   Алгоритм такий:

   1. Визначаємо **розмір одного запису** в байтах:
      `RecordSize = сума_розмірів_усіх_полів`.
   2. Якщо потрібно звернутися до запису з номером `k` (наприклад, нумерація з 0),
      то **початок запису** у файлі:
      `offsetRecord = k * RecordSize`.
   3. Визначаємо **зміщення поля всередині запису**:
      `offsetField = сума_розмірів_попередніх_полів`.
   4. Загальне зміщення у файлі:
      `offset = offsetRecord + offsetField`.

   У C# це виглядає так (через `FileStream.Seek`):

   ```csharp
   // Наприклад, читаємо певне поле запису з індексом k
   long offset = k * RecordSize + offsetField;
   fs.Seek(offset, SeekOrigin.Begin);
   // далі читаємо потрібне поле за допомогою BinaryReader
   ```

---

7. **Як закрити файл? Що відбувається на рівні операційної системи при закритті файла?**

   У C# файл закривають:

   * або явно:

     ```csharp
     fs.Close();
     ```
   * або автоматично через `using` (рекомендовано):

     ```csharp
     using (FileStream fs = new FileStream(...))
     {
         ...
     } // тут fs автоматично закриється
     ```

   На рівні ОС при закритті:

   * **скидаються буфери** – усі незаписані дані реально записуються на диск;
   * **звільняється файловий дескриптор** (handle);
   * знімаються **блокування доступу** до файла (якщо вони були);
   * інші процеси/програми можуть без проблем використовувати цей файл.

---
